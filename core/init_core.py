#!/usr/bin/env python

"""
Exports various methods used to initialize core configuration
"""

import os, sys,logger,subprocess
from mutex_parsers import *

class InitCore:
    
    HEADER_TEXT = """
##############################################################
# This config file has been automatically generated by kmotion
# from www_rc DO NOT CHANGE IT IN ANY WAY !!!
##############################################################
# User defined options
##############################################################
"""

    COMPULSORY_TEXT = """
#############################################################
# Compulsory options
#############################################################
"""

    THREAD_TEXT = """
#############################################################
# Threads
#############################################################
"""


    def __init__(self, kmotion_dir):
        self.log = logger.Logger('init_core', logger.DEBUG)
        self.kmotion_dir = kmotion_dir
        self.kmotion_parser = mutex_kmotion_parser_rd(self.kmotion_dir)
        self.www_parser = mutex_www_parser_rd(self.kmotion_dir)
        
        self.ramdisk_dir = self.kmotion_parser.get('dirs', 'ramdisk_dir')
        self.images_dbase_dir = self.kmotion_parser.get('dirs', 'images_dbase_dir')
        self.port = self.kmotion_parser.get('misc', 'port')
        self.max_feed = self.kmotion_parser.getint('misc', 'max_feed')
        self.version = self.kmotion_parser.get('version', 'string')
        self.title = self.kmotion_parser.get('version', 'title')
        
        self.feed_list = []
        for section in self.www_parser.sections():
            try:
                if 'motion_feed' in section:
                    feed = int(section.replace('motion_feed',''))
                    if self.www_parser.getboolean(section, 'feed_enabled'):
                        self.feed_list.append(feed)
            except:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                self.log('init - error {type}: {value}'.format(**{'type':exc_type, 'value':exc_value}), logger.DEBUG)
        self.feed_list.sort()
    
        self.update_rcs()
        
    
    def update_rcs(self):
        
        """
        Update the rc's during a 'kmotion' or 'kmotion reload'
        
        args    : kmotion_dir ... the 'root' directory of kmotion
                  ramdisk_dir ... the 'root' directory of ramdisk
        excepts :
        return  : none
        """
        
        config_js = '%s/www/www/js/config.js' % self.kmotion_dir
        with open(config_js, 'w') as f_obj:
            print >> f_obj, 'var max_feed=%d;' % self.max_feed
            print >> f_obj, 'var version="%s";' % self.version
            print >> f_obj, 'var title="%s";' % self.title
            print >> f_obj, 'var ramdisk_dir="%s";' % self.ramdisk_dir
        
        
#         # Sets the 'func_f??_enabled' in 'www_rc' by scanning for valid files in 
#         # the 'func' directory. Valid files have the format 'func<01-16>.sh'.
#         self.log('update_rcs() - Setting the \'func_f??_enabled\' in \'www_rc\'', logger.DEBUG)
#         for feed in self.feed_list:
#             if os.path.isfile('%s/func/func%02i.sh' % (self.kmotion_dir, feed)):
#                 self.www_parser.set('system', 'func_f%02i_enabled' % feed, 'true')
#             else:
#                 self.www_parser.set('system', 'func_f%02i_enabled' % feed, 'false')
#         
#         # copy 'msg' to 'www_rc' 
#         self.log('update_rcs() - Copy \'msg\' to \'www_rc\'', logger.DEBUG) 
#         # user generated file so error trap
#         try:
#             with open('../msg') as f_obj:
#                 msg = f_obj.read()
#         except IOError:
#             msg = ''
#             self.log('update_rcs() - unable to read \'msg\'', logger.DEBUG) 
#             
#         msg = msg.replace('\n', '<br>') 
#         self.www_parser.set('system', 'msg', msg)
#         
#         mutex_www_parser_wr(self.kmotion_dir, self.www_parser)
        
  
    def init_ramdisk_dir(self):
        """
        Init the ramdisk setting up the kmotion, events and tmp folders.
        Exception trap in case dir created between test and mkdirs.
        
        args    : ramdisk_dir ... the ramdisk dir, normally '/dev/shm'
        excepts :
        return  : none
        """
        
        self.log('init_ramdisk_dir() - creating \'states\' folder', logger.DEBUG)
        states_dir = os.path.join(self.ramdisk_dir, 'states')
        if not os.path.isdir(states_dir):
            os.makedirs(states_dir)

        for sfile in os.listdir(states_dir):
            state_file = os.path.join(states_dir, sfile)
            if os.path.isfile(state_file):
                self.log('init_ramdisk_dir() - deleting \'%s\' file' % (state_file), logger.DEBUG)
                os.unlink(state_file)
                    
        events_dir = os.path.join(self.ramdisk_dir, 'events')
        if not os.path.isdir(events_dir):
            self.log('init_ramdisk_dir() - creating \'events\' folder', logger.DEBUG) 
            os.makedirs(events_dir)
            
        for efile in os.listdir(events_dir):
            event_file = os.path.join(events_dir, efile)
            if os.path.isfile(event_file) and os.path.getsize(event_file) == 0:
                self.log('delete - {0}'.format(event_file), logger.DEBUG)
                os.unlink(event_file)
        
        for feed in self.feed_list:
            if not os.path.isdir('%s/%02i' % (self.ramdisk_dir, feed)): 
                try:
                    os.makedirs('%s/%02i' % (self.ramdisk_dir, feed))
                    self.log('init_ramdisk_dir() - creating \'%02i\' folder' % feed, logger.DEBUG)
                except OSError:
                    pass
                    
        if not os.path.isdir('%s/tmp' % self.ramdisk_dir): 
            try:
                os.makedirs('%s/tmp' % self.ramdisk_dir)
                self.log('init_ramdisk_dir() - creating \'tmp\' folder', logger.DEBUG)
            except OSError:
                pass   
            
    def set_uid_gid_mutex(self, uid, gid):
        """
        Set the 'mutex', 'logs', 'www_rc', 'kmotion_rc' and 'servo_state' directories 
        with the appropreate 'uid' and 'gid'to allow the apache2 user to have write 
        access.
        
        args    : kmotion_dir ... the 'root' directory of kmotion 
                  uid ...         the user id
                  gid ...         the group id of apache2
        excepts : 
        return  : none
        """
        
        mutex_ = '%s/www/mutex' % self.kmotion_dir
        logs = '%s/logs' % mutex_
        www_rc = '%s/www_rc' % mutex_
        kmotion_rc = '%s/kmotion_rc' % mutex_
        
        os.chown(mutex_, uid, gid)
        os.chmod(mutex_, 0770)
        os.chown(logs, uid, gid)
        os.chmod(logs, 0770)
        os.chown(www_rc, uid, gid)
        os.chmod(www_rc, 0770)
        os.chown(kmotion_rc, uid, gid)
        os.chmod(kmotion_rc, 0770)
    

    def set_uid_gid_named_pipes(self, uid, gid):
        """
        Generate named pipes for function, settings and ptz communications with the 
        appropreate 'uid' and 'gid'. The 'uid' and 'gid' are set to allow the 
        apache2 user to write to these files.
        
        args    : kmotion_dir ... the 'root' directory of kmotion 
                  uid ...         the user id
                  gid ...         the group id of apache2
        excepts : 
        return  : none
        """
        
        # use BASH rather than os.mkfifo(), FIFO bug workaround :)
        fifo_func = '%s/www/fifo_func' % self.kmotion_dir
        if not os.path.exists(fifo_func):
            # os.mkfifo(fifo_func)
            subprocess.call(['mkfifo', fifo_func])
        os.chown(fifo_func, uid, gid)
        os.chmod(fifo_func, 0660)
        
        fifo_settings = '%s/www/fifo_settings_wr' % self.kmotion_dir
        if not os.path.exists(fifo_settings):
            # os.mkfifo(fifo_settings)
            subprocess.call(['mkfifo', fifo_settings])
        os.chown(fifo_settings, uid, gid)
        os.chmod(fifo_settings, 0660)
        
        fifo_ptz = '%s/www/fifo_ptz' % self.kmotion_dir
        if not os.path.exists(fifo_ptz):
            # os.mkfifo(fifo_ptz)
            subprocess.call(['mkfifo', fifo_ptz])
        os.chown(fifo_ptz, uid, gid)
        os.chmod(fifo_ptz, 0660)
    
        fifo_ptz_preset = '%s/www/fifo_ptz_preset' % self.kmotion_dir
        if not os.path.exists(fifo_ptz_preset):
            # os.mkfifo(fifo_ptz_preset)
            subprocess.call(['mkfifo', fifo_ptz_preset])
        os.chown(fifo_ptz_preset, uid, gid)
        os.chmod(fifo_ptz_preset, 0660)
    
    def gen_vhost(self):
        """
        Generate the kmotion vhost file from vhost_template expanding %directory%
        strings to their full paths as defined in kmotion_rc
            
        args    : kmotion_dir ... the 'root' directory of kmotion
        excepts : exit        ... if kmotion_rc cannot be read
        return  : none
        """    

        self.log('gen_vhost() - Generating vhost/kmotion file', logger.DEBUG)
        
        self.log('gen_vhost() - users_digest mode enabled', logger.DEBUG)
        LDAP_block = """
# ** INFORMATION ** Users digest file enabled ...
AuthName "kmotion"
AuthUserFile %s/www/passwords/users_digest\n""" % self.kmotion_dir
        
        try:
            with open('%s/www/vhosts/kmotion' % self.kmotion_dir, 'w') as f_obj1:
                with open('%s/www/templates/vhosts_template' % self.kmotion_dir) as f_obj2:
                    lines = f_obj2.readlines()
            
                for i in range(len(lines)):
                    lines[i] = lines[i].replace('%images_dbase_dir%', self.images_dbase_dir)
                    lines[i] = lines[i].replace('%ramdisk_dir%', self.ramdisk_dir)
                    lines[i] = lines[i].replace('%www_dir%', '%s/www/www' % self.kmotion_dir)
                    lines[i] = lines[i].replace('%logs_dir%', '%s/www/apache_logs' % self.kmotion_dir)
                    lines[i] = lines[i].replace('%port%', self.port)
                    lines[i] = lines[i].replace('%LDAP_block%', LDAP_block)
                    f_obj1.write(lines[i])
        except IOError:
            self.log('ERROR by generating vhost/kmotion file', logger.CRIT)
            self.log(str(sys.exc_info()[1]), logger.CRIT)
        
      
        
if __name__ == '__main__':
    kmotion_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    print kmotion_dir
    print InitCore(kmotion_dir).set_uid_gid_named_pipes(os.getuid(), os.getgid())
    
    


    
    
    
    
    
